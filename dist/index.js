"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.weakModels=weakModels,exports.plugin=void 0;var _mongooseMutex=_interopRequireDefault(require("@chumager/mongoose-mutex")),_promiseHelpers=require("@chumager/promise-helpers"),_lodash=_interopRequireDefault(require("lodash.merge"));function _interopRequireDefault(e){return e&&e.__esModule?e:{default:e}}class localPromise extends Promise{}let lock;(0,_promiseHelpers.promiseHelpers)(localPromise);const plugin=async(e,t={})=>{if(!t.name)throw new Error("option.name is needed to create new weak Model");if(!t.db)throw new Error("option.db is needed to create new weak Model");let{name:o}=t;const{db:a,itdfw:i}=t;delete t.name,delete t.db,delete t.itdfw;const s=[];e.childSchemas.forEach(({schema:e,model:t})=>{t.$isArraySubdocument&&e.set("weakModel")&&s.push({subSchema:e,model:t})}),await Promise.all(s.map(async({subSchema:s,model:n})=>{const{path:l}=n,r=`${o}_${l}`,c=s.set("weakModel");let d;switch(typeof c){case"function":d=await c(s,e,a);break;case"object":d=await c;break;case"boolean":d={}}(0,_lodash.default)(d,t);const{projection:p={},statics:m,methods:u,post:h,extraFields:w,collation:f,position:_,preAggregate:$,postAggregate:b,total:g,set:y,applyPlugins:k=!0,parentName:M}=d,P=o.toLowerCase();if(s.weakModelName=r,s=s.clone(),k&&(s.$globalPluginsApplied=!1),s.add({[P]:{type:e.path("_id").instance,...e.path("_id").options,immutable:!0,parent:!0,...i?{name:M||o,ref:o,filter:!0,pos:0,tablePos:0,hidden:!1}:{}}}),y)for(const e in y)s.set(e,y[e]);s.set("autoCreate",!1),s.set("autoIndex",!1),s.static({parentPath:P,parentModel(){return this.model(o)}}),s.method({parentDocument({lean:e=!1,select:t}={}){const o=this.constructor.parentModel().findById(this[P]);return e&&o.lean(),t&&o.select(t),o}}),_&&s.add({_position:{type:Number,...i?{name:"Nº",tablePos:1,pos:1}:{}}}),g&&s.add({_total:{type:Number,...i?{name:"Tº",tablePos:2,pos:2}:{}}}),Object.keys(p).forEach(t=>{e.path(t)&&1===p[t]&&(s.add(e.pick([t])),s.path(t).options.fromParent=!0,s.path(t).options.immutable=!0)}),s.method("save",(async function(){const e=await this.constructor.model(o).findById(this[P]);if(!e)throw new Error(`there is no parent in ${o} for ${r} document ${this._id}`);let t;if(this._id)t=e[l].id(this._id);else{if(!this._position)throw new Error(`weak model ${r} ain't have _id nor _position\n${JSON.stringify(this,null,2)}`);{const o="Human"===_?this._position-1:this._position;t=e[l][o]}}return t?(t.set(this),t.$locals=this.$locals):e[l].push(this),e.$locals=this.$locals,e.save()}),{suppressWarning:!0}),w&&s.add(w),m&&s.static(m),u&&s.method(u);const x=e.set("collection")||a.pluralize()(o),N=a.pluralize()(r);let j=[{$project:{[o.toLowerCase()]:"$_id",_id:0,[l]:1,...p,...g?{_total:{$size:"$"+l}}:{}}},{$unwind:{path:"$"+l,includeArrayIndex:"_position",preserveNullAndEmptyArrays:!1}},{$replaceRoot:{newRoot:{$mergeObjects:["$$ROOT","$"+l]}}},{$project:{[l]:0}}];"Human"===_&&j.push({$addFields:{_position:{$add:["$_position",1]}}}),$&&(j=[].concat($,j)),b&&(j=[].concat(j,b)),lock({lockName:N}).then(async e=>{try{await a.connection.dropCollection(N)}catch(e){}finally{await a.connection.createCollection(N,{viewOn:x,pipeline:j,...f?{collation:f}:{}}),localPromise.delay(2e4).then(e)}},e=>{if("MutexLockError"!==e.name)throw e}),h&&await h({weakSchema:s,parentSchema:e,db:a,aggregate:j,weakModelName:r}),a.model(r,s),await plugin(s,{name:r,db:a,itdfw:i})}))};async function weakModels(e,t,o=!1){({lock:lock}=(0,_mongooseMutex.default)({db:e,TTL:60}));const{models:a}=e;await Promise.all(Object.keys(a).map(async i=>await plugin(a[i].schema,{name:i,db:e,itdfw:o,...t})))}exports.plugin=plugin;