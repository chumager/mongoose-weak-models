"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.weakModels=weakModels,exports.plugin=void 0;var _mongooseMutex=_interopRequireDefault(require("@chumager/mongoose-mutex")),_promiseHelpers=require("@chumager/promise-helpers");function _interopRequireDefault(e){return e&&e.__esModule?e:{default:e}}class localPromise extends Promise{}let lock;(0,_promiseHelpers.promiseHelpers)(localPromise);const plugin=async(e,t)=>{if(!t.name)throw new Error("option.name is needed to create new weak Model");if(!t.db)throw new Error("option.db is needed to create new weak Model");let{name:o}=t;const{db:a,itdfw:i}=t,s=[];e.childSchemas.forEach(({schema:e,model:t})=>{t.$isArraySubdocument&&e.set("weakModel")&&s.push({subSchema:e,model:t})}),await Promise.all(s.map(async({subSchema:t,model:s})=>{const{path:n}=s,l=`${o}_${n}`,r=t.set("weakModel");let c;switch(typeof r){case"function":c=await r(t,e,a);break;case"object":c=await r;break;case"boolean":c={}}const{projection:d={},statics:p,methods:m,post:u,extraFields:h,collation:w,position:f,preAggregate:_,postAggregate:$,total:b,set:g,applyPlugins:y=!0,parentName:k}=c,M=o.toLowerCase();function P(){return l}if(t.method({weakModelName:P}),t.static({weakModelName:P}),t=t.clone(),y&&(t.$globalPluginsApplied=!1),t.add({[M]:{type:e.path("_id").instance,...e.path("_id").options,immutable:!0,parent:!0,...i?{name:k||o,ref:o,filter:!0,pos:0,tablePos:0,hidden:!1}:{}}}),g)for(const e in g)t.set(e,g[e]);t.set("autoCreate",!1),t.set("autoIndex",!1),t.static({parentPath:M,parentModel(){return this.model(o)}}),t.method({parentDocument({lean:e=!1,select:t}={}){console.log(M,this[M]);const o=this.constructor.parentModel().findById(this[M]);return e&&o.lean(),t&&o.select(t),o}}),f&&t.add({_position:{type:Number,...i?{name:"Nº",tablePos:1,pos:1}:{}}}),b&&t.add({_total:{type:Number,...i?{name:"Tº",tablePos:2,pos:2}:{}}}),Object.keys(d).forEach(o=>{e.path(o)&&1===d[o]&&(t.add(e.pick([o])),t.path(o).options.fromParent=!0,t.path(o).options.immutable=!0)}),t.method("save",(async function(){const e=await this.constructor.model(o).findById(this[M]);if(!e)throw new Error(`there is no parent in ${modelName} for ${l} document ${this._id}`);let t;if(this._id)t=e[n].id(this._id);else{if(!this._position)throw new Error(`weak model ${l} ain't have _id nor _position\n${JSON.stringify(this,null,2)}`);{const o="Human"===f?this._position-1:this._position;t=e[n][o]}}return t?(t.set(this),t.$locals=this.$locals):e[n].push(this),e.$locals=this.$locals,e.save()}),{suppressWarning:!0}),h&&t.add(h),p&&t.static(p),m&&t.method(m);const x=e.set("collection")||a.pluralize()(o),N=a.pluralize()(l);let j=[{$project:{[o.toLowerCase()]:"$_id",_id:0,[n]:1,...d,...b?{_total:{$size:"$"+n}}:{}}},{$unwind:{path:"$"+n,includeArrayIndex:"_position",preserveNullAndEmptyArrays:!1}},{$replaceRoot:{newRoot:{$mergeObjects:["$$ROOT","$"+n]}}},{$project:{[n]:0}}];"Human"===f&&j.push({$addFields:{_position:{$add:["$_position",1]}}}),_&&(j=[].concat(_,j)),$&&(j=[].concat(j,$)),lock({lockName:N}).then(async e=>{try{await a.connection.dropCollection(N)}catch(e){}finally{await a.connection.createCollection(N,{viewOn:x,pipeline:j,...w?{collation:w}:{}}),localPromise.delay(2e4).then(e)}},e=>{if("MutexLockError"!==e.name)throw e}),u&&u(t,e,a),a.model(l,t),await plugin(t,{name:l,db:a,itdfw:i})}))};async function weakModels(e,t=!1){({lock:lock}=(0,_mongooseMutex.default)({db:e,TTL:30}));const{models:o}=e;await Promise.all(Object.keys(o).map(async a=>await plugin(o[a].schema,{name:a,db:e,itdfw:t})))}exports.plugin=plugin;